/*
 *
 *      The RC4 streamcipher written in JavaScript for use in encrypting
 *      text messages during the testing phase of a mobile application's
 *      development.
 *          - by Jason Balthis, 2013 balthis.jason@gmail.com
 *
 */
// ============================================================================
// Flush all of our properties then begin to
// Setup those up that hold the user input
//
// k ==> Keyphrase(Password)
// m ==> Plain-Text/Cipher-Text Message to be encrypted/decrypted
//
// Defines our array that will get generated by the class
//
// s ==> State Box
//
// (TODO) A returned value of -1 from one of our properties,
// is an internal error flag
// ============================================================================
var RC4 = function(k, m) {
    this.sbox, this.key, this.msg = null;
    var s = [];
    this.sbox = [];
    this.key = (k) ? k : -1;
    this.msg = (m) ? m : -1;
    this.sbox[0] = (s) ? 0 : -1;

    // Return Our New Object	
    return this;
};

// prototype object
RC4.prototype = {
    constructor: RC4,

    // Just as the name implies, this method does some basic error checks
    // on the data that was sent to us. It also reformats the key and msg
    // into arrays rather than strings for easier data handling in the
    // alogorithm. Checks each character in both key and msg to be sure
    // that they are within the first 256 characters in the ASCII Set.
    Validate: function() {
        // Check for Internal Error Code Assignment		
        this.key = (this.key == -1) ? -1 : this.key;
        this.msg = (this.msg == -1) ? -1 : this.msg;

        // Format the Key and Msg into arrays
        function toArray(arg) {
            var arr = [],
                i = 0;
            for (i; i < arg.length; i++)
                arr.push(arg.charAt(i));
            return arr;
        }
        this.key = toArray(this.key);
        this.msg = toArray(this.msg);

        // Verify that Our Input is Within the Range of Ascii
        // That We are Going to Be Working With
        function asciiChk(arg) {
            for (var i = 0; i < arg.length; i++) {
                if (arg[i].charCodeAt(0) < 256) {
                    arg[i] = arg[i].charCodeAt(0);
                } else {
                    Ti.API.error("Input Out Of Range - Try Again");
                    break;
                }
            }
            return arg;
        }
        this.key = asciiChk(this.key);
        this.msg = asciiChk(this.msg);
        return this;
    },


    // Method to Initialize our State Box and Permutate it based on the Key 
    Initialize: function() {

        // Fill the 256 Values From 0-255 Into the State Box to populate it
        var i = 0,
            j = 0,
            t = 0,
            count = 0;
        while (count < 256) {
            this.sbox[count] = count;
            count++;
        }
        while (i < 256) {

            // The First Algorithm That Handles the Key Scheduling Begins Here.
            // It uses the Values of the key and the iterations of the loop to
            // Transform the State Box into a permutation Array
            j = (j + (this.sbox[i] + this.key[(i % this.key.length)])) % 256;

            // This Operation swaps the value of s[i] for s[j]			
            t = this.sbox[i];
            this.sbox[i] = this.sbox[j];
            this.sbox[j] = t;
            i++;
        }
        return this;
    },

    // The Method to Generate a Psuedo-Random KeyStream Using the Key Values
    // to Make Calls on the permuted sbox Array.
    Keystream: function() {
        this.kst = [];
        // The Algorithm to Produce the Psuedo-Random KeyStream		
        var i = 0,
            j = 0,
            t = 0,
            count = 0;
        while (count < this.msg.length) {
            i = ((i + 1) % 256);
            j = ((j + this.sbox[i]) % 256);

            // Swap
            t = this.sbox[i];
            this.sbox[i] = this.sbox[j];
            this.sbox[j] = t;

            // Fill the KeyStream Array with our Random Values
            this.kst[count] = this.sbox[(this.sbox[i] + this.sbox[j]) % 256];
            count++;
        }
        return this;
    },

    // The Method to Perform the Encrypting/Decrypting
    Crypt: function() {
        this.out = [];
        var str = '',
            count = 0;
        while (count < this.msg.length) {

            // Simply XOR our Message Text with the Generated Key-Stream to Encrypt/Decrypt 	
            this.out[count] = (this.msg[count] ^ this.kst[count]);

            // Build a String if Outputting to a Display
            str += String.fromCharCode(this.out[count]);
            count = count + 1;
        }
        return str;
    }
};
exports.RC4;